detach("package:base", unload = TRUE)
library(base)
library(architect)
detach("package:architect", unload = TRUE)
remove.packages("architect")
library(magrittr)
library(purrr)
library(keyring)
library(data.table)
library(devtools)
git_creds <- source("C:/Users/Chionesu/OneDrive/Projekz/Templates & Snippets/export_keys.R")$value |>
map(~jsonlite::fromJSON(.x)) |>
rbindlist(idcol = "keyring") |>
setkey(service)
repos <- c("book.of.utilities", "book.of.workflow", "book.of.features", "DBOE", "event.vectors", "smart.data", "architect")
git_creds["github"] %$% map(tcltk::tk_select.list(repos, title = "Choose one or more packages to insall", multiple = TRUE), ~{
install_git(
url = glue::glue("https://github.com/delriaan/{.x}")
, ref = "March2023"
, subdir = "pkg"
, credentials = git2r::cred_user_pass(username = username, password = value)
)
})
git_creds["github"] %$% map(tcltk::tk_select.list(repos, title = "Choose one or more packages to insall", multiple = TRUE), ~{
install_git(
url = glue::glue("https://github.com/delriaan/{.x}")
, ref = "March2023"
, subdir = "pkg"
, credentials = git2r::cred_user_pass(username = username, password = value)
)
})
git_creds["github"] %$% map(tcltk::tk_select.list(repos, title = "Choose one or more packages to insall", multiple = TRUE), ~{
install_git(
url = glue::glue("https://github.com/delriaan/{.x}")
, ref = "March2023"
, subdir = "pkg"
, credentials = git2r::cred_user_pass(username = username, password = value)
)
})
library(architect)
# Basic Usage: mtcars with row names pre-pended >>>
define(mtcars)
# smart.data input >>>
smart_mt <- smart.data::smart.data$new(as.data.table(mtcars, keep.rownames = TRUE))$taxonomy.rule();
library(data.table)
library(stringi)
library(book.of.utilities)
library(book.of.workflow)
# Basic Usage: mtcars with row names pre-pended >>>
define(mtcars)
# smart.data input >>>
smart_mt <- smart.data::smart.data$new(as.data.table(mtcars, keep.rownames = TRUE))$taxonomy.rule();
define(smart_mt, list(j = 1, mpg) ~vs + am + use(identifier, category), ~j + mpg)
define(smart_mt, list(j = 1, mpg) ~vs + am + use(identifier, category), ~j + mpg)
define(smart_mt, ~vs + am + use(identifier, category))
define(smart_mt, x = sum(am^2) ~ use(identifier, category))[]
# No terms variant: output should be equivalent >>>
# debug(define)
define(smart_mt, mean(disp))
define(smart_mt, mean(disp) ~ 1)
# No terms variant: output should be equivalent >>>
# debug(define)
define(smart_mt, mean(disp))
define(smart_mt, mean(disp) ~ 1)
\(x) list(
natural_joins = .x[!grepl("[=$\\^()]", x)] |> stringi::stri_split_regex(pattern = "[, |]", simplify = TRUE)
, equi_joins	= .x[grepl("[=]{2}", x)] 		|> stringi::stri_split_regex(pattern = "[, |]", simplify = TRUE)
, fuzzy_joins	= .x[grepl("[$\\^()]", x)] 	|> stringi::stri_split_regex(pattern = "[, |]", simplify = TRUE)
)
\(x, y){
vars <- stringi::stri_replace_all_fixed(x, " ", "", vectorize_all = FALSE)
if (rlang::is_empty(vars)){ NULL } else {
rlang::exprs(
natural_joins = intersect(names(.this), !!vars)
, equi_joins = !!vars
, fuzzy_joins = purrr::keep(names(.this), \(j) grepl(!!vars, j))
)[[y]]
}
}
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
remove.packages("architect")
getwd()
devtools::check_installed()
check_installed()
?check_installed
rlang::check_installed("purrr")
rlang::check_installed("purrr (>= 1.0.0")
rlang::check_installed("purrr (>= 1.0.0)")
library(architect)
# Basic Usage: mtcars with row names pre-pended >>>
define(mtcars)
# smart.data input >>>
smart_mt <- smart.data::smart.data$new(as.data.table(mtcars, keep.rownames = TRUE))$taxonomy.rule();
library(smart.data)
library(purrr)
library(data.table)
library(stringi)
library(book.of.utilities)
library(book.of.workflow)
# smart.data input >>>
smart_mt <- smart.data::smart.data$new(as.data.table(mtcars, keep.rownames = TRUE))$taxonomy.rule();
define(smart_mt, list(j = 1, mpg) ~vs + am + use(identifier, category), ~j + mpg)
define(smart_mt, ~vs + am + use(identifier, category))
define(smart_mt, x = sum(am^2) ~ use(identifier, category))[]
# No terms variant: output should be equivalent >>>
# debug(define)
define(smart_mt, mean(disp))
define(smart_mt, mean(disp) ~ 1)
# No terms variant: output should be equivalent >>>
# debug(define)
define(smart_mt, mean(disp))
define(smart_mt, mean(disp) ~ 1)
# Define using 'smart.data' input, sending output to "smart cache" and then capturing output >>>
if (hasName(.GlobalEnv, "inspect")){ rm(inspect)}
inspect <- define(
smart_mt
, x = sum(am^2) ~ use(identifier, category)
, smart_key = cyl
, smart.data::smart.data$new(.SD, "defined")$taxonomy.rule()$cache_mgr(action = upd)
)
get.smart("defined")$use(category, identifier, retain = drat)
# pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
install.packages("pkgdown")
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
remotes::install_github("delriaan/architect", "May2023")
install.packages(remotes)
install.packages("remotes")
install.packages("devtools")
install.packages("blogdown")
remotes::install_github("delriaan/architect", "May2023")
remotes::install_github("delriaan/architect", "April2023")
remotes::install_github("delriaan/architect", "April2023", "pkg")
remotes::install_github("delriaan/book.of.utilities", "May2023", "pkg")
remotes::install_github("delriaan/book.of.features", "May2023", "pkg")
remotes::install_github("delriaan/book.of.workflow", "May2023", "pkg")
remotes::install_github("delriaan/book.of.workflow", "April2023", "pkg")
remotes::install_github("delriaan/smart.data", "May2023", "pkg")
remotes::install_github("delriaan/event.vectors", "May2023", "pkg")
remotes::install_github("delriaan/DBOE", "May2023", "pkg")
remotes::install_github("delriaan/smart.data", "April2023", "pkg")
remotes::install_github("delriaan/architect", "April2023", "pkg")
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(architect)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
?data.table
??data.table
remotes::install_github("delriaan/smart.data", subdir="pkg");
remotes::install_github("delriaan/smart.data", subdir="pkg", ref = "November2023");
library(smart.data)
detach("package:smart.data", unload = TRUE)
library(architect)
library(architect)
# Basic Usage: mtcars with row names pre-pended >>>
define(mtcars)
library(architect)
# Basic Usage: mtcars with row names pre-pended >>>
define(mtcars)
# smart.data input >>>
smart_mt <- smart.data::smart.data$new(as.data.table(mtcars, keep.rownames = TRUE))$taxonomy.rule();
# smart.data input >>>
smart.data::smart.start()
smart_mt <- smart.data::smart.data$new(as.data.table(mtcars, keep.rownames = TRUE))$taxonomy.rule();
define(smart_mt, list(j = 1, mpg) ~vs + am + use(identifier, category), ~j + mpg)
define(smart_mt, ~vs + am + use(identifier, category))
define(smart_mt, ~vs + am + use(identifier, category))[]
define(smart_mt, x = sum(am^2) ~ use(identifier, category))[]
library(architect)
# Basic Usage: mtcars with row names pre-pended >>>
define(mtcars)[]
# smart.data input >>>
smart.data::smart.start();
taxonomy_list <- list(
identifier = taxonomy(
term = "identifier"
, desc = "Identifier"
, fields = c("rn"))
, category = taxonomy(
term = "category"
, desc = "Category"
, fields = c("cyl", "gear", "carb")
)
)
smart_mt <- smart.data::smart.data$
new(as.data.table(mtcars, keep.rownames = TRUE))$
taxonomy.rule(!!!taxonomy_list)$
enforce.rules(for_usage)$
cache_mgr(action = upd)
define(
smart_mt
, list(j = 1, mpg) ~vs + am + use(identifier, category)
# , ~j + mpg
)[]
define(smart_mt, ~vs + am + use(identifier, category))[]
define(smart_mt, x = sum(am^2) ~ use(identifier, category))[]
define()
define()[]
define(x = 1:10)[]
define(x = 1:10 ~ 1)[]
as.formula(list(y = 3))
rlang::as_label(list(y = 3))
rlang::expr(list(y = 3))
rlang::expr(list(y = 3)) |> rlang::as_label()
library(architect)
define()[]
define(x = 1:10 ~ 1)[]
define(x = 1:10)[]
debug(define)
define(x = 1:10)[]
.ops
define(x = 1:10)[]
.orig_terms
return(as.formula(expr))
library(architect)
library(architect)
define()[]
define(x = 1:10)[]
define(x = 1:10 ~ 1)[]
define(x = 1:10, y = x * 3)[]
# debug(define)
define()[]
define(x = 1:10, y = x * 3)[]
define(x = 1:10, y = x * 3, list(z = x*y) ~ x)[]
define(x = 1:10, y = x * 3, list(z = x*y) ~ x)
define(list(z = x*y) ~ x)
define(list(z = x*y) ~ x)[]
debug(define)
define(list(z = x*y) ~ x)[]
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
detach("package:architect", unload = TRUE)
# debug(define)
define()[]
define(list(z = x*y) ~ x)[]
define(x = 1:10, y = x * 3, list(z = x*y) ~ x)
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
define(list(z = x*y) ~ x)[]
define(list(z = x*y) ~ x)
define(.(z = x*y) ~ x)
define(.(z = x*y))
define(list(z = x*y))
library(data.table)
define(list(z = x*y))
define(x = 1:10, y = x * 3, list(z = x*y) ~ x)
define(x = 1:10, y = x * 3)
define(x = 1:10, y = x * 3)[]
define(x = 1:10, y = x * 3, .(z = x*y) ~ x)
library(smart.data)
library(purrr)
library(data.table)
library(stringi)
library(book.of.utilities)
library(book.of.workflow)
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
# smart.data input >>>
smart.data::smart.start();
# debug(define)
define()[]
define(list(z = x*y))
define(x = 1:10, y = x * 3)[]
define(x = 1:10, y = x * 3)[]
define(x = 1:10, y = x * 3, .(z = x*y))
define(x = 1:10, y = x * 3, list(z = x*y))
data.table(.init = 0)
data.table(.init = 0)[, x := 1:10]
define(x = 1:10, y = x * 3)[]
define(x = 1:10, y = x * 3, list(z = x*y))
debug(define)
define(x = 1:10, y = x * 3, list(z = x*y))
define(x = 1:10, y = x * 3, list(z = x*y))
define(x = 1:10, y = x * 3, list(z = x*y))
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
# debug(define)
define()[]
define(x = 1:10, y = x * 3)[]
define(x = 1:10, y = x * 3, list(z = x*y))
define(x = 1:10, y = x * 3)[, list(z = x*y))
define(x = 1:10, y = x * 3)[, list(z = x*y)]
define(x = 1:10, y = x * 3, z = x*y)[]
define(x = 1:10, y = x * 3, z = x*y, ~z)[]
debug(define)
define(x = 1:10, y = x * 3, z = x*y, ~z)[]
define(x = 1:10, y = x * 3, z = x*y, ~z)[]
data
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
# debug(define)
define()[]
define(x = 1:10, y = x * 3)[]
define(x = 1:10, y = x * 3, z = x*y, ~z)[]
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
# debug(define)
define()[]
define(x = 1:10, y = x * 3)[]
define(x = 1:10, y = x * 3, z = x*y, ~z)[]
debug(define)
define(x = 1:10, y = x * 3, z = x*y, ~z)[]
undebug(define)
define(data.table(), x = 1:10, y = x * 3, z = x*y, ~z)[]
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
# undebug(define)
define()[]
define(data.table(), x = 1:10, y = x * 3)[]
define(data.table(), x = 1:10, y = x * 3, z = x*y, ~z)[]
data
define(x = 1:10, y = x * 3)[]
define(data.table(), x = 1:10, y = x * 3, z = x*y)[]
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
define(data.table(), x = 1:10, y = x * 3, z = x*y)[]
define(data.table(), x = 1:10, y = x * 3, z = x*y, ~x + z)[]
define(data.table(), x = 1:10, y = x * 3, list(z = 10))[]
define(data.table(), x = 1:10, y = x * 3, list(z = 10) ~ x)[]
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
# undebug(define)
define()[]
source("D:/Imperial Git Repos/architect/pkg/R/architect.R")
# undebug(define)
define()[]
define(x = 1:10, y = x * 3)[]
define(data.table(), x = 1:10, y = x * 3, z = x*y)[]
define(x = 1:10, y = x * 3, z = x*y)[]
define(x = 1:10, y = x * 3, z = x*y, ~x + z)[]
define(data.table(), x = 1:10, y = x * 3, z = x*y, ~x + z)[]
as.data.table(NULL)
define <- function(data = NULL, ..., keep.rownames = TRUE){
#' Define a Data Operation
#'
#' \code{define} allows one to operate on data using one or more formula-based definitions. Data transformation and selection can be achieved with formulas or using standard \code{\link[data.table]{data.table}} syntax in a procedural manner with a single function call.
#'
#' @details
#' \itemize{
#' \item{If \code{data} is a \code{\link[smart.data]{smart.data}} object, the taxonomical references to field names can be accessed by using the \code{use()} syntax in the right-hand side of the formula (e.g., \code{~use(term1, term2) + otherTerm1 + ...}).}
#' \item{When using formulas for \code{...} on an empty \code{\link[data.table]{data.table}} object, set the argument \code{data} to \code{data.table::data.table()}; otherwise, you are likely to get an error.}
#' }
#'
#' @param data The input data (see 'Details')
#' @param ... (\code{\link[rlang]{dots_list}}): Formulas for which the left-hand side (LHS) is an expression containing the operation, and the right-hand side (RHS) contains column names that form a grouping set for the operation (i.e., \code{<expression> ~ col_1 + col_2 + ...}):
#' \itemize{
#' \item{If the form \code{<LHS>~ .} is given, the LHS executes using all columns as the grouping set}
#' \item{If the form \code{<LHS>~ 1} is given, the LHS executes without grouping}
#' \item{If no LHS is given, the operation defaults to selection based on the RHS}
#' }
#' @param keep.rownames See \code{\link[data.table]{data.table}}
#'
#' @return The data modified
#'
#' @examples
#' library(smart.data)
#' smart.start();
#'
#' taxonomy_list <- list(
#' 	identifier = taxonomy(
#' 		term = "identifier"
#' 		, desc = "Identifier"
#' 		, fields = c("rn"))
#' 	, category = taxonomy(
#' 		term = "category"
#' 		, desc = "Category"
#' 		, fields = c("cyl", "gear", "carb")
#' 		)
#' );
#'
#' smart_mt <- smart.data$
#' 	new(as.data.table(mtcars, keep.rownames = TRUE))$
#' 	taxonomy.rule(!!!taxonomy_list)$
#' 	enforce.rules(for_usage)$
#' 	cache_mgr(action = upd);
#'
#' define(
#' 	smart_mt
#' 	, list(j = 1, mpg) ~vs + am + use(identifier, category)
#' 	, ~j + mpg
#' 	)[];
#'
#' define(smart_mt, ~vs + am + use(identifier, category))[];
#'
#' define(smart_mt, x = sum(am^2) ~ use(identifier, category))[];
#'
#' @export
force(data);
.smartData <- fun_expr <- by_args <- NULL;
if (require(smart.data)){
if (smart.data::is.smart(data)){
.smartData <- data$clone(deep = TRUE)
data <- data.table::copy(.smartData$data)
} else{
data <- data.table::as.data.table(data, keep.rownames = keep.rownames)
}
} else {
data <- data.table::as.data.table(data, keep.rownames = keep.rownames)
}
# `.terms_check` is a helper function that checks for the use of the `use()` function in the RHS of the formula:
.terms_check <- \(expr){
if (!grepl("~", rlang::as_label(expr))){
return(expr);
}
# browser()
.orig_terms <- as.formula(expr) |> terms() |> attr("term.labels");
# If any term is a `use()` term, then we need to get the taxonomy
# for each term and replace the term with the taxonomy field names:
if (any(grepl("^use[(]", .orig_terms)) & !rlang::is_empty(.smartData)){
# First, capture the terms that are not `use()` terms:
.terms <- grep("^use[(]", .orig_terms, value = TRUE, invert = TRUE);
# Then, capture the terms that are `use()` terms:
.taxonomy <- grep("^use[(]", .orig_terms, value = TRUE) |>
rlang::parse_expr() |>
as.list() |>
(`[`)(-1) |>
as.character();
# Then convert the `use()` terms to the taxonomy field names:
.taxonomy <- rlang::expr(with(
.smartData$smart.rules$for_usage
, mget(!!.taxonomy) |>
purrr::map(\(tax) tax@fields) |>
purrr::compact() |>
purrr::reduce(c)
));
# Update the formula with the new terms:
expr <- as.formula(expr);
rlang::f_rhs(expr) <- str2lang(paste(c(.terms, eval(.taxonomy)), collapse = " + "));
}
return(expr);
}
# `.func` is the function that is called for each operation:
.func <- \(x, y){
if (!rlang::is_formula(x)){
fun_expr <- x;
by_args <- character()
} else {
f <- eval(unlist(x, recursive = FALSE)) |> data.table::setattr(".Environment", as.environment(data));
fun_expr <- rlang::f_lhs(f = f);
by_args <- stats::terms(f, data = data) |> attr("term.labels");
if (!all(by_args %in% names(data))){ by_args <- character() }
}
.op <- if (!rlang::is_empty(fun_expr)){
# Operation Branch
.out_expr <- if (y != ""){
# Assignment branch
rlang::expr(data[, `:=`(!!y, !!fun_expr)])
} else {
# Operation-only branch
rlang::expr(data[, !!fun_expr])
}
# data.table grouping "by"
if (!(rlang::is_empty(by_args) | identical(character(), by_args))){
.out_expr$by <- by_args
}
.out_expr
} else if (!rlang::is_empty(by_args)){
# Selection Branch
rlang::expr(data[, c(!!!by_args)])
} else {
# Identity
rlang::expr(data)
}
data <<- eval(.op);
};
# `.ops` contains the operations to use to define the data:
.ops <- rlang::enexprs(...) |> purrr::map(.terms_check);
# `.ops` is iterated over using `.func`:
purrr::iwalk(.ops, .func);
return(invisible(data))
}
define(x = 1:10, y = x * 3, z = x*y, ~x + z)[]
# undebug(define)
define()[]
define(x = 1:10, y = x * 3)[]
define(x = 1:10, y = x * 3, z = x*y)[]
define(NULL, x = 1:10, y = x * 3, z = x*y, ~x + z)[]
library(architect)
# Build Site
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(architect)
# Build Site
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(architect)
library(architect)
remotes::install_github("delriaan/book.of.utilities", subdir="pkg");
remotes::install_github("delriaan/book.of.features", subdir="pkg");
remotes::install_github("delriaan/smart.data", subdir="pkg");
remotes::install_github("delriaan/architect", subdir="pkg");
library(architect)
# Build Site
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
# Build Site
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(architect)
# Build Site
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
